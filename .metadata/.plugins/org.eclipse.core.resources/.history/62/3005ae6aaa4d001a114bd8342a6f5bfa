package io.copy;

import java.awt.Color;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import api.ActionPlan;
import core.Aim;
import core.Diagram;
import core.Task;
import java.util.Set;

public class YedReader extends CsvIO {
	List<Task> tasks = new ArrayList<>();
	HashMap<String, Task> tasksByName;
	HashMap<String, String> taskNameById;
	HashMap<String, Double> taskProgressById;

	public YedReader(String filePath) throws IOException {
		super();

		//String fileName = "C:/Users/ffazer/test/test/test.graphml";
		String fileName = "D:/perso/projet/resolutions.graphml";

		taskNameById = readFile(fileName);

	}

	public Diagram getDiagram() {
		return new Diagram(tasks);

	}

	private HashMap<String, String> readFile(String fileName) throws IOException {
		tasksByName = new HashMap<>();
		taskNameById = new HashMap<>();
		taskProgressById = new HashMap<>();

		Document document = null;
		DocumentBuilderFactory factory = null;
		DocumentBuilder builder = null;

		try {
			factory = DocumentBuilderFactory.newInstance();
			builder = factory.newDocumentBuilder();
			document = builder.parse(fileName);
			NodeList nodeList = document.getElementsByTagName("node");

			// lister les tâches
			for (int i = 0; i < nodeList.getLength(); i++) {

				Node nodeNode = nodeList.item(i);

				// récupération de l'ID
				NamedNodeMap attributes = nodeNode.getAttributes();
				Node namedItem = attributes.getNamedItem("id");
				String nodeId = namedItem.getNodeValue();

				// récupération du nom et de l'avancement
				searchNameAndProgress(nodeId, nodeNode.getChildNodes());

			}

			// lister les tâches suivantes
			HashMap<String, List<String>> idNext = new HashMap<>();
			NodeList dependanceList = document.getElementsByTagName("edge");
			// System.out.println("dependanceList : " + nodeList.getLength());

			for (int count = 0; count < dependanceList.getLength(); count++) {

				Node tempNode = dependanceList.item(count);
				NamedNodeMap attributes = tempNode.getAttributes();
				Node sourceNamedItem = attributes.getNamedItem("source");
				String sourceId = sourceNamedItem.getNodeValue();

				Node targetNamedItem = attributes.getNamedItem("target");
				String targetId = targetNamedItem.getNodeValue();
				if (idNext.containsKey(sourceId)) {
					List<String> targetList = idNext.get(sourceId);
					targetList.add(targetId);
					idNext.put(sourceId, targetList);
				} else {
					List<String> targetList = new ArrayList<>();
					targetList.add(targetId);
					idNext.put(sourceId, targetList);
				}
				// System.out.println("source " + sourceId + " " + "target " +
				// targetId);
			}

			// création des tâches
			taskNameById.forEach((id, name) -> {
				Task task;
				if (idNext.containsKey(id)) {
					task = new Task(name);
					tasks.add(task);
				} else {
					task = new Aim(name);
					tasks.add(task);
				}
				tasksByName.put(name, task);
			});

			// ajout des tâches suivantes
			idNext.forEach((id, followers) -> {
				String name = taskNameById.get(id);
				for (String nextId : followers) {
					String nextName = taskNameById.get(nextId);
					Task task = tasksByName.get(name);
					Task next = tasksByName.get(nextName);
					task.addNext(next);
				}
			});

			// ajout de la progression
			taskProgressById.forEach((id, progress) -> {
				String taskName = taskNameById.get(id);
				tasksByName.get(taskName).setProgress(progress);
			});

			Diagram diagram = new Diagram(tasks);

			printDiagram(diagram);

		} catch (

		Exception e) {
			e.printStackTrace();
		}

		return taskNameById;
	}

	/**
	 * impression
	 * 
	 */
	private void printDiagram(Diagram diagram) {
		printFeasibleTask(diagram);

		printWeightTaskAndProgress(diagram);

		printTaskAndPrevious(diagram);

		printProgression(diagram);
	}

	private void printProgression(Diagram diagram) {
		System.out.println("\n******************************************\n");
		System.out.println("Avancement par poid\n");
		double total = 0;
		double alreadyDo = 0;
		double nbFinish = 0;
		for (Task task : diagram.getTasks()) {
			total = total + task.getWeight();
			double taskPercent = task.getWeight() * (task.getProgress() / 100);
			alreadyDo = alreadyDo + taskPercent;
			if (task.isFinish())
				nbFinish++;

		}
		double percent = (alreadyDo / total) * 100;
		double percentFinish = (nbFinish / diagram.getTasks().size()) * 100;
		System.out.println(percent + "%\n");
		System.out.println("Avancement par tâches terminées\n");
		System.out.println(percentFinish + "%\n");
	}

	private void printTaskAndPrevious(Diagram diagram) {
		System.out.println("\n******************************************\n");
		System.out.println("tâches  avec leur prédécesseurs\n");
		for (Task task : diagram.getTasks()) {
			if (task.getPrevious().size() > 0) {
				StringBuilder taskNameAndOrder = new StringBuilder();
				taskNameAndOrder.append(task.getName());
				taskNameAndOrder.append(" : ");
				for (Task previous : task.getPrevious()) {
					taskNameAndOrder.append(previous.getName());
					taskNameAndOrder.append(" - ");
				}
				System.out.println(taskNameAndOrder.toString());
			}
		}
	}

	private void printWeightTaskAndProgress(Diagram diagram) {
		System.out.println("\n******************************************\n");
		System.out.println("ordre des tâches avec leur poids\n");
		for (Task task : diagram.getTasks()) {
			StringBuilder taskNameAndOrder = new StringBuilder();
			taskNameAndOrder.append(task.getWeight());
			taskNameAndOrder.append(" : ");
			taskNameAndOrder.append(task.getName());
			taskNameAndOrder.append(" : ");
			taskNameAndOrder.append(task.getProgress());
			System.out.println(taskNameAndOrder.toString());
		}
	}

	private void printFeasibleTask(Diagram diagram) {
		System.out.println("tâches faisables\n");
		for (Task task : diagram.getFeasibleTask()) {
			StringBuilder feasibleTask = new StringBuilder();
			feasibleTask.append(task.getWeight());
			feasibleTask.append(" ");
			feasibleTask.append(task.getName());
			feasibleTask.append(" ");
			System.out.println(feasibleTask.toString());
		}
	}

	private void searchNameAndProgress(String nodeId, NodeList childNodes) {

		for (int i = 0; i < childNodes.getLength(); i++) {
			Node nodeChild = childNodes.item(i);
			if (nodeChild instanceof Element) {
				String nodeName = nodeChild.getNodeName();
				if ("y:Fill".equals(nodeName)) {
					double progress = getPregrogess(nodeChild);
					taskProgressById.put(nodeId, Double.valueOf(progress));
				}
				if ("y:NodeLabel".equals(nodeName)) {
					String taskName = getContent(nodeChild);
					taskNameById.put(nodeId, taskName);
				} else {
					searchNameAndProgress(nodeId, nodeChild.getChildNodes());
				}
			}
		}

	}

	private String getContent(Node node) {
		String taskName = node.getTextContent();
		return taskName.trim();
	}

	private double getPregrogess(Node node) {
		double progress = 0;
		NamedNodeMap attributes = node.getAttributes();
		Node attributeColor = attributes.getNamedItem("color");
		String colorValue = attributeColor.getNodeValue();

		int r = Integer.valueOf(colorValue.substring(1, 3), 16);
		int g = Integer.valueOf(colorValue.substring(3, 5), 16);
		int b = Integer.valueOf(colorValue.substring(5, 7), 16);

		if (r > 127) {
			r = 255;
		} else {
			r = 0;
		}
		if (g > 127) {
			g = 255;
		} else {
			g = 0;
		}
		if (b > 127) {
			b = 255;
		} else {
			b = 0;
		}

		// vert
		if (r == 0 && g == 255 && b == 0) {
			progress = 100;
		}
		// jaune
		else if (r == 255 && g == 255 && b == 0) {
			progress = 50;
		}

		return progress;

	}

}
